@startuml component_diagram_server

title PC Inventory System - Server Component Diagram

skinparam componentStyle rectangle
skinparam rectangleFontSize 10
skinparam noteFontSize 9

package "pc-inventory-server" {

    ' Entry Point
    rectangle "main.rs\n====\nエントリーポイント\n・非同期ランタイム起動\n・設定ファイル読み込み\n・ログシステム初期化\n・DBプール作成\n・Axumルーター構築\n・サーバー起動\n・0.0.0.0:8080" as Main #LightBlue

    ' Configuration
    rectangle "config.rs\n====\n設定管理\n・ServerConfig構造体\n・ServerSettings\n・DatabaseSettings\n・LoggingSettings\n・ApiSettings\n・load()メソッド" as Config #LightGreen

    ' Data Models
    rectangle "models/pc_info.rs\n====\nデータモデル\n・PcInfo構造体\n・PcInfoRequest\n・PcInfoResponse\n・ErrorResponse\n・serde対応\n・validate()メソッド" as Model #LightYellow

    ' Repository
    rectangle "db/repository.rs\n====\nリポジトリ\n・PcInfoRepository\n・find_by_uuid()\n・create()\n・update()\n・upsert()\n・MySqlPool管理" as Repository #LightCyan

    ' API Handler
    rectangle "handlers/pc_info.rs\n====\nAPIハンドラー\n・handle_pc_info()\n・Json<PcInfoRequest>\n・State<Repository>\n・バリデーション\n・レスポンス生成\n・エラー変換" as Handler #LightCoral

    ' Router
    rectangle "Router\n====\nHTTPルーティング\n・POST /api/pc-info\n・TraceLayerミドルウェア\n・State共有\n・handle_pc_info呼出" as Router #LightSalmon

    ' Logging
    rectangle "logging.rs\n====\nログ管理\n・init_logging()\n・tracing-subscriber\n・ファイルローテーション\n・server.log出力" as Logging #LightGray

    ' Error Handling
    rectangle "error.rs\n====\nエラー処理\n・ServerError列挙型\n・DatabaseError\n・ConfigError\n・InvalidRequest\n・IntoResponse実装\n・HTTPステータス変換" as Error #LightPink

    ' External Systems
    database "MySQL/MariaDB\npc_inventory.pc_info" as DB
    cloud "HTTP Client" as HTTPClient

    ' Call Flow from Entry Point
    Main --> Config : 1. ServerConfig::load()\n設定読み込み
    Main --> Logging : 2. init_logging()\nログ初期化
    Main --> Repository : 3. MySqlPool::connect()\nPcInfoRepository::new()\nDBプール作成
    Main --> Router : 4. Router::new()\nroute設定\nwith_state()\nルーティング構築
    Main --> Router : 5. axum::serve()\nサーバー起動

    HTTPClient --> Router : HTTP POST\n/api/pc-info
    Router --> Handler : リクエスト転送
    Handler --> Model : パース・検証
    Handler --> Repository : upsert(request)
    Repository --> Model : マッピング
    Repository --> DB : SQL実行\nSELECT/INSERT/UPDATE

    Handler ..> Error : エラー処理
    Repository ..> Error : DBエラー
    Config ..> Error : 設定エラー
}

' Processing Flow Details
note bottom of Main
  **main関数の処理フロー**
  ====
  1. 設定読み込み: ServerConfig::load("config.toml")
  2. ログ初期化: init_logging(&config.logging)
  3. DBプール作成:
     MySqlPoolOptions::new()
       .max_connections(config.database.max_connections)
       .connect_timeout(...)
       .connect(&config.database.url).await
  4. リポジトリ作成:
     PcInfoRepository::new(pool)
  5. Axumルーター構築:
     Router::new()
       .route("/api/pc-info", post(handle_pc_info))
       .layer(TraceLayer::new_for_http())
       .with_state(repository)
  6. サーバー起動:
     TcpListener::bind("0.0.0.0:8080")
     axum::serve(listener, app).await
end note

note bottom of Handler
  **handle_pc_info()の処理フロー**
  ====
  1. Axumが自動でJson<PcInfoRequest>にデシリアライズ
  2. payload.validate()でバリデーション
     - uuid必須チェック
  3. State(repo)からリポジトリ取得
  4. repo.upsert(&payload)実行
     - 戻り値: (action, id)
     - action: "created" | "updated"
  5. PcInfoResponse構築
     {
       "status": "success",
       "action": "created",
       "id": 123
     }
  6. Json(response)を返す
  7. エラー時: ServerError -> IntoResponse
     - 400 Bad Request: InvalidRequest
     - 500 Internal Server Error: DatabaseError
end note

note bottom of Repository
  **upsert()の処理詳細**
  ====
  UPSERT実装:

  1. find_by_uuid(uuid)
     SELECT * FROM pc_info
     WHERE uuid = ? LIMIT 1

  2. 結果が None の場合:
     create(request)
     INSERT INTO pc_info (
       uuid, mac_address, network_type,
       user_name, ip_address, os,
       os_version, model_name,
       created_at, updated_at
     ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
     → action = "created"

  3. 結果が Some(pc_info) の場合:
     update(id, request)
     UPDATE pc_info SET
       mac_address = ?, network_type = ?,
       user_name = ?, ip_address = ?,
       os = ?, os_version = ?,
       model_name = ?, updated_at = NOW()
     WHERE id = ?
     → action = "updated"

  4. (action, id) を返す
end note

note bottom of Model
  **データモデル構造体**
  ====
  1. PcInfo (DBレコード)
     - id, uuid, mac_address, network_type
     - user_name, ip_address, os, os_version
     - model_name, created_at, updated_at
     - sqlx::FromRow派生

  2. PcInfoRequest (APIリクエスト)
     - uuid, mac_address, network_type
     - user_name, ip_address, os, os_version
     - model_name
     - serde::Deserialize派生
     - validate()メソッド

  3. PcInfoResponse (成功レスポンス)
     - status: "success"
     - action: "created" | "updated"
     - id: i32
     - serde::Serialize派生

  4. ErrorResponse (エラーレスポンス)
     - status: "error"
     - message: String
end note

note bottom of DB
  **データベース構造**
  ====
  テーブル: pc_info

  制約:
  - PRIMARY KEY: id
  - UNIQUE: uuid
    → 同じPCは1レコードのみ

  インデックス:
  - idx_uuid (uuid)
  - idx_updated_at (updated_at)

  UPSERT処理により:
  - 初回: INSERT (created_at, updated_at設定)
  - 2回目以降: UPDATE (updated_atのみ更新)
end note

@enduml
